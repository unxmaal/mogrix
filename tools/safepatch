#!/usr/bin/perl
# safepatch - Safe, paranoid file patching for mogrix builds
#
# Unlike sed, this tool:
#   - Uses exact string matching by default (no regex surprises)
#   - FAILS if the pattern is not found (no silent no-ops)
#   - FAILS if the pattern matches more times than expected
#   - Creates backups by default
#   - Validates inputs thoroughly
#   - Provides clear, actionable error messages
#
# Modes:
#   replace (default):  --old 'text' --new 'replacement'
#   delete-line:        --delete-line 'text on line to remove'
#   insert-after:       --old 'anchor text' --insert-after 'new line(s)'
#   insert-before:      --old 'anchor text' --insert-before 'new line(s)'
#
# Exit codes:
#   0 - Success
#   1 - Pattern not found
#   2 - Wrong number of matches
#   3 - File error (not found, not readable, not writable)
#   4 - Invalid arguments
#   5 - Backup failed
#   6 - Write failed

use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Copy qw(copy);
use File::Basename qw(basename);

# Exit codes
use constant {
    EXIT_SUCCESS        => 0,
    EXIT_NOT_FOUND      => 1,
    EXIT_WRONG_COUNT    => 2,
    EXIT_FILE_ERROR     => 3,
    EXIT_BAD_ARGS       => 4,
    EXIT_BACKUP_FAILED  => 5,
    EXIT_WRITE_FAILED   => 6,
};

# ANSI colors for terminal output
my $RED    = "\e[31m";
my $GREEN  = "\e[32m";
my $YELLOW = "\e[33m";
my $BLUE   = "\e[34m";
my $BOLD   = "\e[1m";
my $RESET  = "\e[0m";

# Disable colors if not a terminal
if (!-t STDERR) {
    $RED = $GREEN = $YELLOW = $BLUE = $BOLD = $RESET = '';
}

sub usage {
    my $prog = basename($0);
    print STDERR <<"EOF";
${BOLD}Usage:${RESET}
  $prog <file> --old 'pattern' --new 'replacement'
  $prog <file> --delete-line 'text on line to remove'
  $prog <file> --old 'anchor' --insert-after 'new text'
  $prog <file> --old 'anchor' --insert-before 'new text'
  $prog <file> --insert-top 'new text'

${BOLD}Modes:${RESET}
  Replace (default):   Find --old text and replace with --new text
  Delete line:         Remove entire lines containing --delete-line text
  Insert after:        Insert --insert-after text on new line after --old match
  Insert before:       Insert --insert-before text on new line before --old match
  Insert top:          Prepend --insert-top text at beginning of file (no anchor needed)

${BOLD}Match Options:${RESET}
  --old, -o TEXT      Text to find (exact match by default)
  --new, -n TEXT      Replacement text (replace mode)
  --delete-line TEXT  Delete lines containing this text
  --insert-after TEXT Insert this text after line matching --old
  --insert-before TEXT Insert this text before line matching --old
  --insert-top TEXT   Prepend this text at the beginning of the file
  --regex, -r         Treat --old as a Perl regex instead of exact string
  --count, -c NUM     Expected number of matches (default: 1)
                      Use 0 to allow any number of matches

${BOLD}General Options:${RESET}
  --dry-run, -d       Show what would be changed without modifying
  --no-backup         Don't create .bak backup file
  --quiet, -q         Suppress success messages
  --verbose, -v       Show detailed match information
  --help, -h          Show this help

${BOLD}Exit Codes:${RESET}
  0  Success
  1  Pattern not found in file
  2  Wrong number of matches (found N, expected M)
  3  File error (missing, unreadable, or unwritable)
  4  Invalid arguments
  5  Backup creation failed
  6  Write failed

${BOLD}Examples:${RESET}
  # Simple replacement (expects exactly 1 match)
  $prog config.h --old '#define DEBUG 0' --new '#define DEBUG 1'

  # Replace all occurrences (any count OK)
  $prog Makefile --old 'gcc' --new 'mips-sgi-irix6.5-gcc' --count 0

  # Delete lines containing a pattern
  $prog configure.ac --delete-line 'AC_CHECK_LIB(cap,'

  # Insert a line after a match
  $prog main.c --old '#include <stdio.h>' --insert-after '#include "compat.h"'

  # Insert before with regex matching
  $prog Makefile --old 'CFLAGS\\s*=' --insert-before 'CFLAGS += -I/opt/sgug' --regex

  # Regex replacement
  $prog src.c --old 'pthread_\\w+_np' --new 'compat_\\0' --regex

${BOLD}Why not sed?${RESET}
  sed silently does nothing if a pattern doesn't match. This tool fails
  loudly, preventing hours of debugging when a source file changes or
  a pattern is wrong. sed also uses regex by default, where metacharacters
  like ., *, [, etc. cause unexpected matches.
EOF
    exit(EXIT_BAD_ARGS);
}

sub error {
    my ($msg, $code) = @_;
    print STDERR "${RED}${BOLD}ERROR:${RESET} $msg\n";
    exit($code);
}

sub warning {
    my ($msg) = @_;
    print STDERR "${YELLOW}${BOLD}WARNING:${RESET} $msg\n";
}

sub info {
    my ($msg) = @_;
    print STDERR "${GREEN}${BOLD}OK:${RESET} $msg\n";
}

sub debug {
    my ($msg) = @_;
    print STDERR "${BLUE}DEBUG:${RESET} $msg\n";
}

# Build the regex pattern from user input
sub build_pattern {
    my ($text, $use_regex) = @_;
    if ($use_regex) {
        # Validate the regex compiles
        eval { qr/$text/ };
        if ($@) {
            my $err = $@;
            $err =~ s/ at \(eval \d+\).*//s;
            error("Invalid regex: $err", EXIT_BAD_ARGS);
        }
        return $text;
    }
    return quotemeta($text);
}

# Find all occurrences and their positions
sub find_matches {
    my ($content, $pattern, $use_regex) = @_;
    my @matches;
    my $re = build_pattern($pattern, $use_regex);

    while ($content =~ /($re)/g) {
        my $match_start = $-[0];
        my $match_end = $+[0];

        # Find line number and context
        my $prefix = substr($content, 0, $match_start);
        my $line_num = 1 + ($prefix =~ tr/\n//);

        # Get the line containing the match
        my $line_start = rindex($content, "\n", $match_start) + 1;
        my $line_end = index($content, "\n", $match_end);
        $line_end = length($content) if $line_end < 0;
        my $line = substr($content, $line_start, $line_end - $line_start);

        push @matches, {
            position   => $match_start,
            end        => $match_end,
            line_num   => $line_num,
            line       => $line,
            line_start => $line_start,
            line_end   => $line_end,
            col        => $match_start - $line_start + 1,
            matched    => $1,
        };
    }

    return @matches;
}

# Find lines containing a pattern (for delete-line and insert modes)
sub find_line_matches {
    my ($content, $pattern, $use_regex) = @_;
    my @matches;
    my $re = build_pattern($pattern, $use_regex);
    my @lines = split /\n/, $content, -1;

    for my $i (0 .. $#lines) {
        if ($lines[$i] =~ /$re/) {
            push @matches, {
                line_num   => $i + 1,
                line       => $lines[$i],
                line_index => $i,
                col        => 1,
            };
        }
    }

    return @matches;
}

# Show context around a match
sub show_match_context {
    my ($content, $match, $old_text, $index) = @_;
    my $line_num = $match->{line_num};
    my $line = $match->{line};

    # Truncate long lines for display
    my $max_len = 120;
    my $display_line = $line;
    if (length($display_line) > $max_len) {
        $display_line = substr($display_line, 0, $max_len) . "...";
    }

    print STDERR "  Match #" . ($index + 1) . " at line $line_num, column $match->{col}:\n";
    print STDERR "    ${BLUE}$line_num:${RESET} $display_line\n";
}

# Validate file
sub validate_file {
    my ($file, $dry_run) = @_;

    if (!-e $file) {
        error("File not found: $file", EXIT_FILE_ERROR);
    }
    if (-d $file) {
        error("Path is a directory, not a file: $file", EXIT_FILE_ERROR);
    }
    if (!-r $file) {
        error("File is not readable: $file", EXIT_FILE_ERROR);
    }
    if (!$dry_run && !-w $file) {
        error("File is not writable: $file", EXIT_FILE_ERROR);
    }
    if (-B $file) {
        warning("File appears to be binary: $file");
    }
}

# Read file contents
sub read_file {
    my ($file) = @_;
    open(my $fh, '<', $file) or error("Cannot read $file: $!", EXIT_FILE_ERROR);
    local $/;
    my $content = <$fh>;
    close($fh);
    return $content;
}

# Write file contents (with optional backup)
sub write_file {
    my ($file, $content, $no_backup, $verbose) = @_;

    if (!$no_backup) {
        my $backup = "$file.bak";
        if (!copy($file, $backup)) {
            error("Failed to create backup $backup: $!", EXIT_BACKUP_FAILED);
        }
        debug("Created backup: $backup") if $verbose;
    }

    open(my $fh, '>', $file) or error("Cannot write $file: $!", EXIT_WRITE_FAILED);
    print $fh $content;
    close($fh) or error("Failed to close $file: $!", EXIT_WRITE_FAILED);
}

# Validate and report match count
sub validate_matches {
    my ($matches_ref, $expected_count, $pattern, $file, $verbose, $dry_run) = @_;
    my @matches = @$matches_ref;
    my $found_count = scalar(@matches);

    # Report what we found
    if ($verbose || $dry_run) {
        if ($found_count == 0) {
            print STDERR "Pattern not found in $file\n";
            print STDERR "Looking for:\n";
            print STDERR "  ${YELLOW}" . (substr($pattern, 0, 200)) . "${RESET}";
            print STDERR "..." if length($pattern) > 200;
            print STDERR "\n";
        } else {
            print STDERR "Found $found_count match" . ($found_count == 1 ? "" : "es") . " in $file:\n";
            for my $i (0 .. $#matches) {
                show_match_context(undef, $matches[$i], $pattern, $i);
            }
        }
    }

    if ($found_count == 0) {
        my $hint = "";
        if ($pattern =~ /^\s/ || $pattern =~ /\s$/) {
            $hint = "\nHint: Pattern has leading/trailing whitespace - verify it matches the file exactly";
        }
        if ($pattern =~ /\t/) {
            $hint .= "\nHint: Pattern contains tabs - the file might use spaces instead (or vice versa)";
        }
        error("Pattern not found in $file" . $hint, EXIT_NOT_FOUND);
    }

    if ($expected_count > 0 && $found_count != $expected_count) {
        my $msg = "Found $found_count match" . ($found_count == 1 ? "" : "es");
        $msg .= ", expected $expected_count in $file";

        if ($found_count > $expected_count) {
            $msg .= "\n\nThis likely means the pattern is too broad and matches unintended locations.";
            $msg .= "\nUse --verbose to see all matches, or use a more specific pattern.";
            $msg .= "\nIf you really want to match all $found_count, use --count 0";
        } else {
            $msg .= "\n\nThis likely means the source file has changed.";
            $msg .= "\nVerify the pattern is still correct for this version.";
        }

        if (!$verbose && !$dry_run) {
            print STDERR "\nMatches found:\n";
            for my $i (0 .. $#matches) {
                show_match_context(undef, $matches[$i], $pattern, $i);
            }
        }

        error($msg, EXIT_WRONG_COUNT);
    }

    return $found_count;
}

# Mode: replace (original behavior)
sub do_replace {
    my ($file, $old_text, $new_text, $expected_count, $use_regex,
        $dry_run, $no_backup, $quiet, $verbose) = @_;

    my $content = read_file($file);
    my @matches = find_matches($content, $old_text, $use_regex);
    my $found_count = validate_matches(\@matches, $expected_count, $old_text, $file, $verbose, $dry_run);

    if ($dry_run) {
        print STDERR "\n${YELLOW}DRY RUN:${RESET} Would replace $found_count occurrence";
        print STDERR "s" if $found_count != 1;
        print STDERR " in $file\n";
        print STDERR "Old: ${RED}" . (substr($old_text, 0, 100)) . "${RESET}";
        print STDERR "..." if length($old_text) > 100;
        print STDERR "\nNew: ${GREEN}" . (substr($new_text, 0, 100)) . "${RESET}";
        print STDERR "..." if length($new_text) > 100;
        print STDERR "\n";
        return;
    }

    my $re = build_pattern($old_text, $use_regex);
    $content =~ s/$re/$new_text/g;

    write_file($file, $content, $no_backup, $verbose);

    if (!$quiet) {
        info("Patched $file ($found_count replacement" . ($found_count == 1 ? "" : "s") . ")");
    }
}

# Mode: delete-line
sub do_delete_line {
    my ($file, $pattern, $expected_count, $use_regex,
        $dry_run, $no_backup, $quiet, $verbose) = @_;

    my $content = read_file($file);
    my @matches = find_line_matches($content, $pattern, $use_regex);
    my $found_count = validate_matches(\@matches, $expected_count, $pattern, $file, $verbose, $dry_run);

    if ($dry_run) {
        print STDERR "\n${YELLOW}DRY RUN:${RESET} Would delete $found_count line";
        print STDERR "s" if $found_count != 1;
        print STDERR " from $file\n";
        return;
    }

    # Delete lines in reverse order to preserve indices
    my @lines = split /\n/, $content, -1;
    for my $match (reverse @matches) {
        splice @lines, $match->{line_index}, 1;
    }
    $content = join("\n", @lines);

    write_file($file, $content, $no_backup, $verbose);

    if (!$quiet) {
        info("Deleted $found_count line" . ($found_count == 1 ? "" : "s") . " from $file");
    }
}

# Mode: insert-after
sub do_insert_after {
    my ($file, $anchor, $insert_text, $expected_count, $use_regex,
        $dry_run, $no_backup, $quiet, $verbose) = @_;

    my $content = read_file($file);
    my @matches = find_line_matches($content, $anchor, $use_regex);
    my $found_count = validate_matches(\@matches, $expected_count, $anchor, $file, $verbose, $dry_run);

    if ($dry_run) {
        print STDERR "\n${YELLOW}DRY RUN:${RESET} Would insert after $found_count line";
        print STDERR "s" if $found_count != 1;
        print STDERR " in $file\n";
        print STDERR "Insert: ${GREEN}" . (substr($insert_text, 0, 100)) . "${RESET}";
        print STDERR "..." if length($insert_text) > 100;
        print STDERR "\n";
        return;
    }

    # Insert in reverse order to preserve indices
    my @lines = split /\n/, $content, -1;
    for my $match (reverse @matches) {
        splice @lines, $match->{line_index} + 1, 0, $insert_text;
    }
    $content = join("\n", @lines);

    write_file($file, $content, $no_backup, $verbose);

    if (!$quiet) {
        info("Inserted after $found_count line" . ($found_count == 1 ? "" : "s") . " in $file");
    }
}

# Mode: insert-before
sub do_insert_before {
    my ($file, $anchor, $insert_text, $expected_count, $use_regex,
        $dry_run, $no_backup, $quiet, $verbose) = @_;

    my $content = read_file($file);
    my @matches = find_line_matches($content, $anchor, $use_regex);
    my $found_count = validate_matches(\@matches, $expected_count, $anchor, $file, $verbose, $dry_run);

    if ($dry_run) {
        print STDERR "\n${YELLOW}DRY RUN:${RESET} Would insert before $found_count line";
        print STDERR "s" if $found_count != 1;
        print STDERR " in $file\n";
        print STDERR "Insert: ${GREEN}" . (substr($insert_text, 0, 100)) . "${RESET}";
        print STDERR "..." if length($insert_text) > 100;
        print STDERR "\n";
        return;
    }

    # Insert in reverse order to preserve indices
    my @lines = split /\n/, $content, -1;
    for my $match (reverse @matches) {
        splice @lines, $match->{line_index}, 0, $insert_text;
    }
    $content = join("\n", @lines);

    write_file($file, $content, $no_backup, $verbose);

    if (!$quiet) {
        info("Inserted before $found_count line" . ($found_count == 1 ? "" : "s") . " in $file");
    }
}

# Mode: insert-top (prepend to beginning of file)
sub do_insert_top {
    my ($file, $insert_text, $dry_run, $no_backup, $quiet, $verbose) = @_;

    my $content = read_file($file);

    if ($dry_run) {
        print STDERR "\n${YELLOW}DRY RUN:${RESET} Would prepend to $file\n";
        print STDERR "Insert: ${GREEN}" . (substr($insert_text, 0, 100)) . "${RESET}";
        print STDERR "..." if length($insert_text) > 100;
        print STDERR "\n";
        return;
    }

    $content = $insert_text . "\n" . $content;

    write_file($file, $content, $no_backup, $verbose);

    if (!$quiet) {
        info("Prepended to $file");
    }
}

# Main
sub main {
    my ($file, $old_text, $new_text, $delete_line, $insert_after, $insert_before, $insert_top);
    my $expected_count = 1;
    my $use_regex = 0;
    my $dry_run = 0;
    my $no_backup = 0;
    my $quiet = 0;
    my $verbose = 0;
    my $help = 0;

    GetOptions(
        'old|o=s'           => \$old_text,
        'new|n=s'           => \$new_text,
        'delete-line=s'     => \$delete_line,
        'insert-after=s'    => \$insert_after,
        'insert-before=s'   => \$insert_before,
        'insert-top=s'      => \$insert_top,
        'regex|r'           => \$use_regex,
        'count|c=i'         => \$expected_count,
        'dry-run|d'         => \$dry_run,
        'no-backup'         => \$no_backup,
        'quiet|q'           => \$quiet,
        'verbose|v'         => \$verbose,
        'help|h'            => \$help,
    ) or usage();

    usage() if $help;

    # Get file argument
    $file = shift @ARGV;

    if (!defined $file) {
        error("No file specified", EXIT_BAD_ARGS);
    }
    if ($expected_count < 0) {
        error("--count cannot be negative", EXIT_BAD_ARGS);
    }
    if (@ARGV) {
        error("Unexpected arguments: " . join(' ', @ARGV), EXIT_BAD_ARGS);
    }

    # Determine mode and validate args
    my $mode_count = 0;
    $mode_count++ if defined $delete_line;
    $mode_count++ if defined $insert_after;
    $mode_count++ if defined $insert_before;
    $mode_count++ if defined $insert_top;

    if ($mode_count > 1) {
        error("Cannot combine --delete-line, --insert-after, --insert-before, and --insert-top", EXIT_BAD_ARGS);
    }

    validate_file($file, $dry_run);

    if (defined $insert_top) {
        # Insert-top mode (prepend to file, no anchor needed)
        if (length($insert_top) == 0) {
            error("--insert-top cannot be empty", EXIT_BAD_ARGS);
        }
        do_insert_top($file, $insert_top, $dry_run, $no_backup, $quiet, $verbose);

    } elsif (defined $delete_line) {
        # Delete-line mode
        if (length($delete_line) == 0) {
            error("--delete-line cannot be empty", EXIT_BAD_ARGS);
        }
        do_delete_line($file, $delete_line, $expected_count, $use_regex,
                       $dry_run, $no_backup, $quiet, $verbose);

    } elsif (defined $insert_after) {
        # Insert-after mode
        if (!defined $old_text) {
            error("--old is required with --insert-after (specifies anchor line)", EXIT_BAD_ARGS);
        }
        if (length($old_text) == 0) {
            error("--old cannot be empty", EXIT_BAD_ARGS);
        }
        do_insert_after($file, $old_text, $insert_after, $expected_count, $use_regex,
                        $dry_run, $no_backup, $quiet, $verbose);

    } elsif (defined $insert_before) {
        # Insert-before mode
        if (!defined $old_text) {
            error("--old is required with --insert-before (specifies anchor line)", EXIT_BAD_ARGS);
        }
        if (length($old_text) == 0) {
            error("--old cannot be empty", EXIT_BAD_ARGS);
        }
        do_insert_before($file, $old_text, $insert_before, $expected_count, $use_regex,
                         $dry_run, $no_backup, $quiet, $verbose);

    } else {
        # Replace mode (default)
        if (!defined $old_text) {
            error("--old is required", EXIT_BAD_ARGS);
        }
        if (!defined $new_text) {
            error("--new is required", EXIT_BAD_ARGS);
        }
        if (length($old_text) == 0) {
            error("--old cannot be empty", EXIT_BAD_ARGS);
        }
        if ($old_text eq $new_text) {
            error("--old and --new are identical - nothing to do", EXIT_BAD_ARGS);
        }
        do_replace($file, $old_text, $new_text, $expected_count, $use_regex,
                   $dry_run, $no_backup, $quiet, $verbose);
    }

    exit(EXIT_SUCCESS);
}

main();
