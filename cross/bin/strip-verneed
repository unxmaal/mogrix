#!/usr/bin/env python3
"""Strip IRIX-incompatible ELF dynamic tags from shared libraries.

IRIX rld crashes on:
1. GNU symbol versioning (VERNEED/VERSYM) — generated by GNU ld when linking
   against versioned libs like libstdc++.so.6
2. DT_INIT_ARRAY/DT_FINI_ARRAY — IRIX rld doesn't process these; constructors
   must use .ctors/.init instead. Our linker script redirects .init_array inputs
   into .ctors, but this tool catches any residual tags.

Zeroes the dynamic tags AND section headers/data so rld ignores them completely.

Usage: strip-verneed <elf-file> [<elf-file> ...]
"""
import struct
import sys
import os

# ELF constants
ET_DYN = 3  # Shared object
EM_MIPS = 8
PT_DYNAMIC = 2
DT_NULL = 0
DT_INIT_ARRAY = 25
DT_FINI_ARRAY = 26
DT_INIT_ARRAYSZ = 27
DT_FINI_ARRAYSZ = 28
DT_FLAGS_1 = 0x6ffffffb
DT_VERSYM = 0x6ffffff0
DT_VERDEF = 0x6ffffffc
DT_VERDEFNUM = 0x6ffffffd
DT_VERNEED = 0x6ffffffe
DT_VERNEEDNUM = 0x6fffffff

# All dynamic tags to strip — IRIX rld crashes on GNU extensions it doesn't recognize
TAGS_TO_STRIP = {
    DT_VERSYM, DT_VERDEF, DT_VERDEFNUM, DT_VERNEED, DT_VERNEEDNUM,
    DT_INIT_ARRAY, DT_FINI_ARRAY, DT_INIT_ARRAYSZ, DT_FINI_ARRAYSZ,
    DT_FLAGS_1,
}

# Section types
SHT_GNU_versym = 0x6fffffff
SHT_GNU_verneed = 0x6ffffffe
SHT_GNU_verdef = 0x6ffffffd
SHT_INIT_ARRAY = 14
SHT_FINI_ARRAY = 15


def strip_verneed(filepath):
    with open(filepath, 'r+b') as f:
        # Read ELF header
        e_ident = f.read(16)
        if e_ident[:4] != b'\x7fELF':
            print(f"  {filepath}: not an ELF file, skipping")
            return False

        ei_class = e_ident[4]  # 1=32bit, 2=64bit
        ei_data = e_ident[5]   # 1=little, 2=big
        if ei_class != 1:
            print(f"  {filepath}: not 32-bit ELF, skipping")
            return False

        endian = '>' if ei_data == 2 else '<'

        # Parse ELF32 header
        f.seek(0)
        ehdr = f.read(52)
        e_type = struct.unpack_from(endian + 'H', ehdr, 16)[0]
        e_machine = struct.unpack_from(endian + 'H', ehdr, 18)[0]
        e_phoff = struct.unpack_from(endian + 'I', ehdr, 28)[0]
        e_phentsize = struct.unpack_from(endian + 'H', ehdr, 42)[0]
        e_phnum = struct.unpack_from(endian + 'H', ehdr, 44)[0]
        e_shoff = struct.unpack_from(endian + 'I', ehdr, 32)[0]
        e_shentsize = struct.unpack_from(endian + 'H', ehdr, 46)[0]
        e_shnum = struct.unpack_from(endian + 'H', ehdr, 48)[0]

        if e_type != ET_DYN:
            print(f"  {filepath}: not a shared library (type={e_type}), skipping")
            return False

        # Find PT_DYNAMIC segment to locate .dynamic section
        dynamic_offset = None
        dynamic_size = None
        for i in range(e_phnum):
            f.seek(e_phoff + i * e_phentsize)
            phdr = f.read(e_phentsize)
            p_type = struct.unpack_from(endian + 'I', phdr, 0)[0]
            if p_type == PT_DYNAMIC:
                dynamic_offset = struct.unpack_from(endian + 'I', phdr, 4)[0]
                dynamic_size = struct.unpack_from(endian + 'I', phdr, 16)[0]
                break

        if dynamic_offset is None:
            print(f"  {filepath}: no PT_DYNAMIC segment, skipping")
            return False

        # Read all dynamic entries, remove IRIX-incompatible ones, compact
        entries = []
        f.seek(dynamic_offset)
        pos = dynamic_offset
        while pos < dynamic_offset + dynamic_size:
            f.seek(pos)
            entry = f.read(8)
            if len(entry) < 8:
                break
            d_tag = struct.unpack_from(endian + 'I', entry, 0)[0]
            d_val = struct.unpack_from(endian + 'I', entry, 4)[0]
            if d_tag == DT_NULL:
                break
            entries.append((d_tag, d_val))
            pos += 8

        # Filter out bad tags
        tags_zeroed = sum(1 for t, v in entries if t in TAGS_TO_STRIP)
        entries = [(t, v) for t, v in entries if t not in TAGS_TO_STRIP]

        # Write compacted entries back + DT_NULL terminator
        if tags_zeroed > 0:
            f.seek(dynamic_offset)
            for t, v in entries:
                f.write(struct.pack(endian + 'II', t, v))
            # Fill remaining space with DT_NULL entries
            remaining = (dynamic_size // 8) - len(entries)
            for _ in range(remaining):
                f.write(struct.pack(endian + 'II', DT_NULL, 0))

        # Also zero the section headers for gnu.version* sections
        sections_zeroed = 0
        for i in range(e_shnum):
            sh_offset_in_file = e_shoff + i * e_shentsize
            f.seek(sh_offset_in_file)
            shdr = f.read(e_shentsize)
            sh_type = struct.unpack_from(endian + 'I', shdr, 4)[0]
            if sh_type in (SHT_GNU_versym, SHT_GNU_verneed, SHT_GNU_verdef,
                          SHT_INIT_ARRAY, SHT_FINI_ARRAY):
                # Zero the section data offset and size
                sh_data_offset = struct.unpack_from(endian + 'I', shdr, 16)[0]
                sh_data_size = struct.unpack_from(endian + 'I', shdr, 20)[0]
                # Zero the section header type to SHT_NULL
                f.seek(sh_offset_in_file + 4)
                f.write(struct.pack(endian + 'I', 0))  # SHT_NULL
                # Zero the actual section data
                if sh_data_size > 0 and sh_data_offset > 0:
                    f.seek(sh_data_offset)
                    f.write(b'\x00' * sh_data_size)
                sections_zeroed += 1

        if tags_zeroed > 0 or sections_zeroed > 0:
            print(f"  {filepath}: zeroed {tags_zeroed} dynamic tags, {sections_zeroed} section headers")
            return True
        else:
            print(f"  {filepath}: no version sections found")
            return False


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <elf-file> [<elf-file> ...]")
        sys.exit(1)

    modified = 0
    for filepath in sys.argv[1:]:
        if strip_verneed(filepath):
            modified += 1

    if modified > 0:
        print(f"Stripped GNU version info from {modified} file(s)")


if __name__ == '__main__':
    main()
