IRIX rld has no ELF TLS support (__tls_get_addr is not provided by any
runtime library). Disable thread_local usage:
1. Exclude __sgi from Q_COMPILER_THREAD_LOCAL (like FreeBSD exclusion)
   - qlogging.cpp and qrandom.cpp have fallback paths when this is unset
2. Replace thread_local in qthread_unix.cpp with pure pthread_key_t
   - The file already had pthread_key_t as a parallel mechanism
3. Remove thread_local from qtimezoneprivate_tz.cpp (plain static is safe
   for a read-only timezone name cache)

--- a/src/corelib/global/qcompilerdetection.h
+++ b/src/corelib/global/qcompilerdetection.h
@@ -783,7 +783,7 @@
 #      define Q_COMPILER_TEMPLATE_ALIAS
 #    endif
 #    if __has_feature(cxx_thread_local)
-#      if !defined(__FreeBSD__) /* FreeBSD clang fails on __cxa_thread_atexit */
+#      if !defined(__FreeBSD__) && !defined(__sgi) /* FreeBSD/IRIX: no ELF TLS */
 #        define Q_COMPILER_THREAD_LOCAL
 #      endif
 #    endif
--- a/src/corelib/thread/qthread_unix.cpp
+++ b/src/corelib/thread/qthread_unix.cpp
@@ -109,7 +109,7 @@
 enum { ThreadPriorityResetFlag = 0x80000000 };


-static thread_local QThreadData *currentThreadData = nullptr;
+/* IRIX: thread_local removed — use pthread_key_t exclusively (no ELF TLS) */

 static pthread_once_t current_thread_data_once = PTHREAD_ONCE_INIT;
 static pthread_key_t current_thread_data_key;
@@ -117,10 +117,6 @@
 static void destroy_current_thread_data(void *p)
 {
     QThreadData *data = static_cast<QThreadData *>(p);
-    // thread_local variables are set to zero before calling this destructor function,
-    // if they are internally using pthread-specific data management,
-    // so we need to set it back to the right value...
-    currentThreadData = data;
     if (data->isAdopted) {
         QThread *thread = data->thread.loadAcquire();
         Q_ASSERT(thread);
@@ -129,10 +125,6 @@
         thread_p->finish(thread);
     }
     data->deref();
-
-    // ... but we must reset it to zero before returning so we aren't
-    // leaving a dangling pointer.
-    currentThreadData = nullptr;
 }

 static void create_current_thread_data_key()
@@ -157,13 +149,14 @@
 // Utility functions for getting, setting and clearing thread specific data.
 static QThreadData *get_thread_data()
 {
-    return currentThreadData;
+    pthread_once(&current_thread_data_once, create_current_thread_data_key);
+    return static_cast<QThreadData *>(pthread_getspecific(current_thread_data_key));
 }

 static void set_thread_data(QThreadData *data)
 {
-    currentThreadData = data;
     pthread_once(&current_thread_data_once, create_current_thread_data_key);
+    /* IRIX: pthread_key_t is the sole TLS mechanism */
     pthread_setspecific(current_thread_data_key, data);
 }

--- a/src/corelib/time/qtimezoneprivate_tz.cpp
+++ b/src/corelib/time/qtimezoneprivate_tz.cpp
@@ -1310,7 +1310,7 @@
         ianaId = ianaId.mid(1);

     if (ianaId.isEmpty()) {
-        thread_local static ZoneNameReader reader;
+        static ZoneNameReader reader; /* IRIX: no ELF TLS — plain static is safe for read-only cache */
         ianaId = reader.name();
     }

