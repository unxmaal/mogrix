#!/bin/sh
#
# IRIX cross-compiler wrapper using clang + vvuk's LLD
#
# This wrapper handles:
# - Preprocess only (-E): uses clang directly
# - Compile only (-c): uses clang directly
# - Link only (.o files, no .c): uses LLD linker wrapper
# - Compile+link (has .c and no -c): compiles with clang, links with LLD
#
# Deployed by: mogrix setup-cross
#

# Configurable paths - set by mogrix setup-cross
SYSROOT="${IRIX_SYSROOT:-/opt/irix-sysroot}"
STAGING="${SGUG_STAGING:-/opt/sgug-staging/usr/sgug}"
CLANG="${IRIX_CLANG:-/opt/cross/bin/clang}"
LD="${STAGING}/bin/irix-ld"

# Header search order:
# 1. SGUG clang compat headers (fix IRIX headers for clang)
# 2. SGUG staging headers (cross-built packages)
# 3. IRIX sysroot headers (pristine IRIX)
#
# Define IRIX C++ namespace macros as empty for C code
# -mxgot: 32-bit GOT offsets. Without this, LLD creates secondary GOTs for
# large libraries that IRIX rld cannot displace, causing SIGSEGV.
CLANG_FLAGS="--target=mips-sgi-irix6.5 --sysroot=$SYSROOT -mabi=n32 -march=mips3 -mxgot"
# Force-include our stdarg.h BEFORE anything else to define va_list correctly
# IRIX's stdio_core.h defines va_list as char* which conflicts with clang builtins
CLANG_FLAGS="$CLANG_FLAGS -include $STAGING/include/dicl-clang-compat/stdarg.h"
# Force-include time.h to ensure struct timespec is defined as "struct timespec"
# (not "struct __timespec"). IRIX sys/timespec.h only maps __timespec→timespec
# when __TIME_H__ is set. Without this, signal.h (and other headers) can include
# sys/timespec.h before time.h, leaving the struct with the wrong name.
# BUT: skip for assembly files (.S/.s) — the assembler can't parse C declarations.
_has_asm_source=false
for _arg in "$@"; do
    case "$_arg" in *.S|*.s) _has_asm_source=true; break ;; esac
done
if [ "$_has_asm_source" = "false" ]; then
    CLANG_FLAGS="$CLANG_FLAGS -include $SYSROOT/usr/include/time.h"
fi
CLANG_FLAGS="$CLANG_FLAGS -isystem $STAGING/include/mogrix-compat/generic"
CLANG_FLAGS="$CLANG_FLAGS -isystem $STAGING/include/dicl-clang-compat"
CLANG_FLAGS="$CLANG_FLAGS -isystem $STAGING/include"
CLANG_FLAGS="$CLANG_FLAGS -isystem $SYSROOT/usr/include"
CLANG_FLAGS="$CLANG_FLAGS -D_SGI_SOURCE -D_SGI_MP_SOURCE -D_SGI_REENTRANT_FUNCTIONS"
CLANG_FLAGS="$CLANG_FLAGS -Dsgi=1 -D__sgi=1 -D_COMPILER_VERSION=730 -D_LANGUAGE_C=1 -D_LONGLONG=1"
# IRIX is Unix — many packages (slang, mc, etc.) check __unix__ for Unix-specific code
CLANG_FLAGS="$CLANG_FLAGS -Dunix=1 -D__unix__=1 -D__unix=1"
# Define __mips for multiarch headers (OpenSSL configuration.h needs this)
CLANG_FLAGS="$CLANG_FLAGS -D__mips=1"
# Override _MIPS_ISA - clang sets _MIPS_ISA_MIPS64 which IRIX headers don't recognize
# IRIX 6.5 N32 uses MIPS3 ISA (R4000 and later)
CLANG_FLAGS="$CLANG_FLAGS -U_MIPS_ISA -D_MIPS_ISA=_MIPS_ISA_MIPS3"
CLANG_FLAGS="$CLANG_FLAGS -D__SGI_LIBC_NAMESPACE_QUALIFIER="
CLANG_FLAGS="$CLANG_FLAGS -D__SGI_LIBC_BEGIN_NAMESPACE_STD="
CLANG_FLAGS="$CLANG_FLAGS -D__SGI_LIBC_END_NAMESPACE_STD="
CLANG_FLAGS="$CLANG_FLAGS -D__SGI_LIBC_BEGIN_EXTERN_C="
CLANG_FLAGS="$CLANG_FLAGS -D__SGI_LIBC_END_EXTERN_C="
# Use plain string literals for Xt/Motif resource names instead of XtStrings/_XmStrings
# offset form. The offset form generates R_MIPS_REL32 relocations that IRIX rld doesn't
# apply in static data sections, leaving raw offsets that crash XrmPermStringToQuark.
CLANG_FLAGS="$CLANG_FLAGS -DXTSTRINGDEFINES -DXMSTRINGDEFINES"
# Use .ctors/.dtors instead of .init_array — IRIX rld doesn't support init_array
CLANG_FLAGS="$CLANG_FLAGS -fno-use-init-array"

# Handle --version and -v (compiler identification for build systems like meson)
for arg in "$@"; do
    case "$arg" in
        --version|-v|-V|--help|-dumpversion|-dumpmachine|-print-search-dirs|-print-*)
            exec $CLANG $CLANG_FLAGS "$@"
            ;;
    esac
done

# Expand response files (@file) — meson uses these for large link commands.
# Shell scripts can't read @file syntax; the linker flag parsing below needs
# to see the actual arguments. Only expand if an @file argument is present.
has_rspfile=false
for arg in "$@"; do
    case "$arg" in @*) has_rspfile=true; break ;; esac
done
if [ "$has_rspfile" = "true" ]; then
    expanded_args=""
    for arg in "$@"; do
        case "$arg" in
            @*)
                rspfile="${arg#@}"
                if [ -f "$rspfile" ]; then
                    # Response files have all args on one line, space-separated.
                    # Strip single quotes (meson quotes $ORIGIN rpath args).
                    expanded_args="$expanded_args $(sed "s/'//g" "$rspfile")"
                else
                    expanded_args="$expanded_args $arg"
                fi
                ;;
            *)
                expanded_args="$expanded_args $arg"
                ;;
        esac
    done
    # Re-set positional parameters to expanded args
    # Note: this loses quoting for filenames with spaces, but response files
    # are only used for link commands which don't have such filenames.
    set -- $expanded_args
fi

# Check if this is preprocess-only (-E flag present)
preprocess_only=false
if echo " $* " | grep -q " -E "; then
    preprocess_only=true
fi

# Check if this is compile-only (-c flag present)
compile_only=false
if echo " $* " | grep -q " -c "; then
    compile_only=true
fi

# Check if there are any .c or .S source files in the arguments
has_source=false
for arg in "$@"; do
    case "$arg" in
        *.c|*.S|*.s)
            has_source=true
            break
            ;;
    esac
done

# Check if this is just linking (.o files only)
link_only=false
if [ "$has_source" = "false" ]; then
    link_only=true
fi

if [ "$preprocess_only" = "true" ]; then
    # Preprocess only - use clang directly
    exec $CLANG $CLANG_FLAGS "$@"
elif [ "$compile_only" = "true" ]; then
    # Compile only - use clang directly
    exec $CLANG $CLANG_FLAGS "$@"
elif [ "$link_only" = "true" ]; then
    # Link only - filter out compile-only flags and pass to LLD wrapper
    link_args=""
    next_is_output=false
    skip_next_arg=false
    for arg in "$@"; do
        if [ "$skip_next_arg" = "true" ]; then
            skip_next_arg=false
            continue
        fi
        if [ "$next_is_output" = "true" ]; then
            link_args="$link_args -o $arg"
            next_is_output=false
            continue
        fi
        case "$arg" in
            -o)
                next_is_output=true
                ;;
            # Translate -Wl,xxx,yyy to xxx yyy (linker passthrough flags)
            -Wl,*)
                # Strip -Wl, prefix and split remaining commas into spaces
                ld_flag=$(echo "$arg" | sed 's/^-Wl,//' | tr ',' ' ')
                link_args="$link_args $ld_flag"
                ;;
            # Skip two-argument compiler flags (flag + next-arg path)
            # Must be checked BEFORE the glob patterns below
            -idirafter|-isystem|-iwithprefix|-iwithprefixbefore|-iprefix|-include|-imacros|-isysroot|-MF|-MT|-MQ)
                skip_next_arg=true
                ;;
            # Skip compile-only flags (but not -Wl which is handled above)
            # Handles concatenated forms like -I/path, -isystem/path, -DFOO
            -D*|-I*|-isystem*|-idirafter*|-iprefix*|-iwithprefix*|-include*|-imacros*|-isysroot*|-W*|-O*|-g|-g[0-9]|-ggdb*|-gdwarf*|-gz*|-std=*|-c|-Q*|-f*|-m*)
                ;;
            # Skip compiler flags that LLD doesn't understand
            -static|-dynamic|-Bdynamic|-Bstatic|-pedantic|-pedantic-errors)
                ;;
            -pipe|-pthread|-traditional|-ansi|-w)
                ;;
            *)
                link_args="$link_args $arg"
                ;;
        esac
    done
    exec $LD $link_args
else
    # Compile + link in one step
    # We need to compile sources to objects, then link

    # Collect source files, output file, and other args
    sources=""
    objects=""
    output=""
    other_args=""
    libs=""
    next_is_output=false

    link_args=""
    for arg in "$@"; do
        if [ "$next_is_output" = "true" ]; then
            output="$arg"
            next_is_output=false
            continue
        fi
        case "$arg" in
            -o)
                next_is_output=true
                ;;
            *.c|*.S|*.s)
                sources="$sources $arg"
                ;;
            *.o|*.a)
                objects="$objects $arg"
                ;;
            *.so|*.so.*)
                # Direct shared library references
                libs="$libs $arg"
                ;;
            -l*|-L*)
                libs="$libs $arg"
                ;;
            # Translate -Wl,xxx,yyy to xxx yyy for linker
            -Wl,*)
                ld_flag=$(echo "$arg" | sed 's/^-Wl,//' | tr ',' ' ')
                link_args="$link_args $ld_flag"
                ;;
            -D*|-I*|-W*|-O*|-g*|-f*|-m*|-std=*|-Q*)
                other_args="$other_args $arg"
                ;;
            # Skip link-only flags during compile phase
            -static|-dynamic|-Bdynamic|-Bstatic)
                ;;
            -shared)
                # Pass -shared to the linker
                link_args="$link_args -shared"
                ;;
            *)
                # Pass through other args
                other_args="$other_args $arg"
                ;;
        esac
    done

    # Default output name
    if [ -z "$output" ]; then
        output="a.out"
    fi

    # Compile sources to temp objects
    tmpdir=$(mktemp -d)
    trap "rm -rf $tmpdir" EXIT

    compiled_objs=""
    for src in $sources; do
        base=$(basename "$src" | sed 's/\.[cSs]$//')
        obj="$tmpdir/${base}.o"
        $CLANG $CLANG_FLAGS $other_args -c -o "$obj" "$src" || exit $?
        compiled_objs="$compiled_objs $obj"
    done

    # Link everything
    exec $LD $link_args -o "$output" $compiled_objs $objects $libs
fi
